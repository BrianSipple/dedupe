<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>core.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id="background"></div>
<div id='container'>
  <div class='section'>
    <div class='docs'><h1>core.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">lr</span>
<span class="kn">from</span> <span class="nn">dedupe.distance.affinegap</span> <span class="kn">import</span> <span class="n">normalizedAffineGapDistance</span> <span class="k">as</span> <span class="n">stringDistance</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>Return random combinations of indicies for a square matrix of</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">randomPairs</span><span class="p">(</span><span class="n">n_records</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">zero_indexed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <p>size n records"""</p>
<p>if n_records &lt; 2 :
    raise ValueError("Needs at least two records")
n = n_records * (n_records - 1) / 2</p>
<p>if sample_size &gt;= n:
    random_indices = numpy.arange(n)
    numpy.random.shuffle(random_indices)
else:
    try:
        random_indices = numpy.array(random.sample(xrange(n), sample_size))
    except OverflowError:
        # If the population is very large relative to the sample
        # size than we'll get very few duplicates by chance
        logging.warning("There may be duplicates in the sample")
        sample = numpy.array([random.sample(xrange(n_records), 2)
                              for _ in xrange(sample_size)])
        return numpy.sort(sample, axis=1)</p>
<p>b = 1 - 2 * n_records</p>
<p>x = numpy.trunc((-b - numpy.sqrt(b ** 2 - 8 * random_indices)) / 2)
y = random_indices + x * (b + x + 2) / 2 + 1</p>
<p>if not zero_indexed:
    x += 1
    y += 1</p>
<p>return numpy.column_stack((x, y))</p>
<p>dataSample(d, sample_size):</p>
<p>random_pairs = randomPairs(len(d), sample_size)</p>
<p>return tuple(((k_1, d[k_1]), (k_2, d[k_2])) for (k_1, k_2) in random_pairs)</p>
<p>trainModel(training_data, data_model, alpha=.001):
'''Use logistic regression to train weights for all fields in the data model'''
labels = training_data['label']
examples = training_data['distances']</p>
<p>(weight, bias) = lr.lr(labels, examples, alpha)</p>
<p>fields = sorted(data_model['fields'].keys())</p>
<p>for (i, name) in enumerate(fields):
    data_model['fields'][name]['weight'] = float(weight[i])</p>
<p>data_model['bias'] = bias</p>
<p>return data_model</p>
<p>fieldDistances(candidates, data_model):
fields = data_model['fields']
record_dtype = [('pairs', 'i4', 2), ('distances', 'f4', (len(fields), ))]</p>
<p>(candidates_1, candidates_2) = itertools.tee(candidates, 2)</p>
<p>key_pairs = (candidate[0] for candidate_pair in candidates_1
             for candidate in candidate_pair)</p>
<p>record_pairs = ((candidate_1[1], candidate_2[1]) 
                for (candidate_1, candidate_2) in candidates_2)</p>
<p>_field_distances = buildFieldDistances(record_pairs, fields)</p>
<p>field_distances = numpy.zeros(_field_distances.shape[0],
                              dtype=record_dtype)</p>
<p>field_distances['pairs'] = numpy.fromiter(key_pairs, 'i4').reshape(-1, 2)
field_distances['distances'] = _field_distances</p>
<p>return field_distances</p>
<p>buildFieldDistances(record_pairs, fields):</p>
<p>field_comparators = [(field, v['comparator'])
                     for field, v in fields.items()
                     if v['type'] not in ('Missing Data',
                                          'Interaction')]</p>
<p>missing_field_indices = [i for i, (field, v) 
                         in enumerate(fields.items())
                         if 'Has Missing' in v and v['Has Missing']]</p>
<p>field_names = fields.keys()</p>
<p>interactions = []
for field in field_names :
    if fields[field]['type'] == 'Interaction' :
        interaction_indices = []
        for interaction_field in fields[field]['Interaction Fields'] :
            interaction_indices.append(field_names.index(interaction_field))
        interactions.append(interaction_indices)</p>
<p>field_distances = numpy.fromiter((compare(record_pair[0][field],
                                          record_pair[1][field]) 
                                  for record_pair in record_pairs 
                                  for field, compare in field_comparators), 
                                 'f4')
field_distances = field_distances.reshape(-1,len(field_comparators))</p>
<p>interaction_distances = numpy.empty((field_distances.shape[0],
                                     len(interactions)))</p>
<p>for i, interaction in enumerate(interactions) :
    a = numpy.prod(field_distances[...,interaction], axis=1)
    interaction_distances[...,i] = a</p>
<p>field_distances = numpy.concatenate((field_distances,
                                     interaction_distances),
                                    axis=1)</p>
<p>missing_data = numpy.isnan(field_distances)</p>
<p>field_distances[missing_data] = 0</p>
<p>missing_indicators = 1-missing_data[:,missing_field_indices]</p>
<p>field_distances = numpy.concatenate((field_distances,
                                     1-missing_data[:,missing_field_indices]),
                                    axis=1)</p>
<p>return field_distances</p>
<p>scorePairs(field_distances, data_model):
fields = data_model['fields']
field_names = sorted(data_model['fields'].keys())</p>
<p>field_weights = [fields[name]['weight'] for name in field_names]
bias = data_model['bias']</p>
<p>distances = field_distances['distances']</p>
<p>scores = numpy.dot(distances, field_weights)</p>
<p>scores = numpy.exp(scores + bias) / (1 + numpy.exp(scores + bias))</p>
<p>return scores</p>
<p>scoreDuplicates(candidates, data_model, threshold=None):</p>
<p>score_dtype = [('pairs', 'i4', 2), ('score', 'f4', 1)]
scored_pairs = numpy.zeros(0, dtype=score_dtype)</p>
<p>complete = False
chunk_size = 5000
i = 1
while not complete:</p>
<pre><code>can_slice = list(itertools.islice(candidates, 0, chunk_size))

field_distances = fieldDistances(can_slice, data_model)
duplicate_scores = scorePairs(field_distances, data_model)

scored_pairs = numpy.append(scored_pairs,
                            numpy.array(zip(field_distances['pairs'],
                                            duplicate_scores),
                                        dtype=score_dtype)[duplicate_scores &gt; threshold], 
                            axis=0)
i += 1
if len(field_distances) &lt; chunk_size:
    complete = True
    logging.info('num chunks %d' % i)
</code></pre>
<p>logging.info('all scores %d' % scored_pairs.shape)
scored_pairs = numpy.unique(scored_pairs)
logging.info('unique scores %d' % scored_pairs.shape)</p>
<p>return scored_pairs</p>
<p>s frozendict(dict):
'''
A data type for hashable dictionaries
From http://code.activestate.com/recipes/414283-frozen-dictionaries/
'''</p>
<p>def _blocked_attribute(obj):
    raise AttributeError('A frozendict cannot be modified.')</p>
<p>_blocked_attribute = property(_blocked_attribute)</p>
<p><strong>delitem</strong> = <strong>setitem</strong> = clear = _blocked_attribute
pop = popitem = setdefault = update = _blocked_attribute</p>
<p>def <strong>new</strong>(cls, <em>args):
    new = dict.<strong>new</strong>(cls)
    dict.<strong>init</strong>(new, </em>args)
    return new</p>
<p>def <strong>init</strong>(self, *args):
    pass</p>
<p>def <strong>hash</strong>(self):
    try:
        return self._cached_hash
    except AttributeError:
        h = self._cached_hash = hash(tuple(sorted(self.items())))
        return h</p>
<p>{{ http://code.activestate.com/recipes/576693/ (r9)
ckport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
sses Python2.7's test suite and incorporates all the latest updates.</p>
<p>from thread import get_ident as _get_ident
pt ImportError:
from dummy_thread import get_ident as _get_ident</p>
<p>from _abcoll import KeysView, ValuesView, ItemsView
pt ImportError:
pass</p>
<p>s OrderedDict(dict):
'Dictionary that remembers insertion order'</p>
<h1>An inherited dict maps keys to values.</h1>
<h1>The inherited dict provides <strong>getitem</strong>, <strong>len</strong>, <strong>contains</strong>, and get.</h1>
<h1>The remaining methods are order-aware.</h1>
<h1>Big-O running times for all methods are the same as for regular dictionaries.</h1>
<h1>The internal self.__map dictionary maps keys to links in a doubly linked list.</h1>
<h1>The circular doubly linked list starts and ends with a sentinel element.</h1>
<h1>The sentinel element never gets deleted (this simplifies the algorithm).</h1>
<h1>Each link is stored as a list of length three:  [PREV, NEXT, KEY].</h1>
<p>def <strong>init</strong>(self, <em>args, </em>*kwds):
    '''Initialize an ordered dictionary.  Signature is the same as for
    regular dictionaries, but keyword arguments are not recommended
    because their insertion order is arbitrary.</p>
<pre><code>'''
if len(args) &gt; 1:
    raise TypeError('expected at most 1 arguments, got %d' % len(args))
try:
    self.__root
except AttributeError:
    self.__root = root = []                     # sentinel node
    root[:] = [root, root, None]
    self.__map = {}
self.__update(*args, **kwds)
</code></pre>
<p>def <strong>setitem</strong>(self, key, value, dict_setitem=dict.<strong>setitem</strong>):
    'od.<strong>setitem</strong>(i, y) &lt;==&gt; od[i]=y'
    # Setting a new item creates a new link which goes at the end of the linked
    # list, and the inherited dictionary is updated with the new key/value pair.
    if key not in self:
        root = self.<strong>root
        last = root[0]
        last[1] = root[0] = self.</strong>map[key] = [last, root, key]
    dict_setitem(self, key, value)</p>
<p>def <strong>delitem</strong>(self, key, dict_delitem=dict.<strong>delitem</strong>):
    'od.<strong>delitem</strong>(y) &lt;==&gt; del od[y]'
    # Deleting an existing item uses self.<strong>map to find the link which is
    # then removed by updating the links in the predecessor and successor nodes.
    dict_delitem(self, key)
    link_prev, link_next, key = self.</strong>map.pop(key)
    link_prev[1] = link_next
    link_next[0] = link_prev</p>
<p>def <strong>iter</strong>(self):
    'od.<strong>iter</strong>() &lt;==&gt; iter(od)'
    root = self.__root
    curr = root[1]
    while curr is not root:
        yield curr[2]
        curr = curr[1]</p>
<p>def <strong>reversed</strong>(self):
    'od.<strong>reversed</strong>() &lt;==&gt; reversed(od)'
    root = self.__root
    curr = root[0]
    while curr is not root:
        yield curr[2]
        curr = curr[0]</p>
<p>def clear(self):
    'od.clear() -&gt; None.  Remove all items from od.'
    try:
        for node in self.<strong>map.itervalues():
            del node[:]
        root = self.</strong>root
        root[:] = [root, root, None]
        self.__map.clear()
    except AttributeError:
        pass
    dict.clear(self)</p>
<p>def popitem(self, last=True):
    '''od.popitem() -&gt; (k, v), return and remove a (key, value) pair.
    Pairs are returned in LIFO order if last is true or FIFO order if false.</p>
<pre><code>'''
if not self:
    raise KeyError('dictionary is empty')
root = self.__root
if last:
    link = root[0]
    link_prev = link[0]
    link_prev[1] = root
    root[0] = link_prev
else:
    link = root[1]
    link_next = link[1]
    root[1] = link_next
    link_next[0] = root
key = link[2]
del self.__map[key]
value = dict.pop(self, key)
return key, value
</code></pre>
<h1>-- the following methods do not depend on the internal structure --</h1>
<p>def keys(self):
    'od.keys() -&gt; list of keys in od'
    return list(self)</p>
<p>def values(self):
    'od.values() -&gt; list of values in od'
    return [self[key] for key in self]</p>
<p>def items(self):
    'od.items() -&gt; list of (key, value) pairs in od'
    return [(key, self[key]) for key in self]</p>
<p>def iterkeys(self):
    'od.iterkeys() -&gt; an iterator over the keys in od'
    return iter(self)</p>
<p>def itervalues(self):
    'od.itervalues -&gt; an iterator over the values in od'
    for k in self:
        yield self[k]</p>
<p>def iteritems(self):
    'od.iteritems -&gt; an iterator over the (key, value) items in od'
    for k in self:
        yield (k, self[k])</p>
<p>def update(*args, <strong>kwds):
    '''od.update(E, </strong>F) -&gt; None.  Update od from dict/iterable E and F.</p>
<pre><code>If E is a dict instance, does:           for k in E: od[k] = E[k]
If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
Or if E is an iterable of items, does:   for k, v in E: od[k] = v
In either case, this is followed by:     for k, v in F.items(): od[k] = v

'''
if len(args) &gt; 2:
    raise TypeError('update() takes at most 2 positional '
                    'arguments (%d given)' % (len(args),))
elif not args:
    raise TypeError('update() takes at least 1 argument (0 given)')
self = args[0]
# Make progressively weaker assumptions about "other"
other = ()
if len(args) == 2:
    other = args[1]
if isinstance(other, dict):
    for key in other:
        self[key] = other[key]
elif hasattr(other, 'keys'):
    for key in other.keys():
        self[key] = other[key]
else:
    for key, value in other:
        self[key] = value
for key, value in kwds.items():
    self[key] = value
</code></pre>
<p><strong>update = update  # let subclasses override update without breaking </strong>init__</p>
<p>__marker = object()</p>
<p>def pop(self, key, default=__marker):
    '''od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
    If key is not found, d is returned if given, otherwise KeyError is raised.</p>
<pre><code>'''
if key in self:
    result = self[key]
    del self[key]
    return result
if default is self.__marker:
    raise KeyError(key)
return default
</code></pre>
<p>def setdefault(self, key, default=None):
    'od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od'
    if key in self:
        return self[key]
    self[key] = default
    return default</p>
<p>def <strong>repr</strong>(self, _repr_running={}):
    'od.<strong>repr</strong>() &lt;==&gt; repr(od)'
    call_key = id(self), _get_ident()
    if call_key in _repr_running:
        return '...'
    _repr_running[call_key] = 1
    try:
        if not self:
            return '%s()' % (self.<strong>class</strong>.<strong>name</strong>,)
        return '%s(%r)' % (self.<strong>class</strong>.<strong>name</strong>, self.items())
    finally:
        del _repr_running[call_key]</p>
<p>def <strong>reduce</strong>(self):
    'Return state information for pickling'
    items = [k, self<a href="k,%20self[k.html">k</a> for k in self]
    inst_dict = vars(self).copy()
    for k in vars(OrderedDict()):
        inst_dict.pop(k, None)
    if inst_dict:
        return (self.<strong>class</strong>, (items,), inst_dict)
    return self.<strong>class</strong>, (items,)</p>
<p>def copy(self):
    'od.copy() -&gt; a shallow copy of od'
    return self.<strong>class</strong>(self)</p>
<p>@classmethod
def fromkeys(cls, iterable, value=None):
    '''OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S
    and values equal to v (which defaults to None).</p>
<pre><code>'''
d = cls()
for key in iterable:
    d[key] = value
return d
</code></pre>
<p>def <strong>eq</strong>(self, other):
    '''od.<strong>eq</strong>(y) &lt;==&gt; od==y.  Comparison to another OD is order-sensitive
    while comparison to a regular mapping is order-insensitive.</p>
<pre><code>'''
if isinstance(other, OrderedDict):
    return len(self)==len(other) and self.items() == other.items()
return dict.__eq__(self, other)
</code></pre>
<p>def <strong>ne</strong>(self, other):
    return not self == other</p>
<h1>-- the following methods are only used in Python 2.7 --</h1>
<p>def viewkeys(self):
    "od.viewkeys() -&gt; a set-like object providing a view on od's keys"
    return KeysView(self)</p>
<p>def viewvalues(self):
    "od.viewvalues() -&gt; an object providing a view on od's values"
    return ValuesView(self)</p>
<p>def viewitems(self):
    "od.viewitems() -&gt; a set-like object providing a view on od's items"
    return ItemsView(self)
nd of http://code.activestate.com/recipes/576693/ }}}</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
